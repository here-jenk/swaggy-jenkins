/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * The version of the OpenAPI document: 1.5.1-pre.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api

import java.text.SimpleDateFormat

import org.openapitools.client.model.BranchImpl
import org.openapitools.client.model.FavoriteImpl
import org.openapitools.client.model.GithubOrganization
import org.openapitools.client.model.GithubScm
import org.openapitools.client.model.MultibranchPipeline
import org.openapitools.client.model.Organisation
import org.openapitools.client.model.Pipeline
import org.openapitools.client.model.PipelineActivity
import org.openapitools.client.model.PipelineFolderImpl
import org.openapitools.client.model.PipelineImpl
import org.openapitools.client.model.PipelineRun
import org.openapitools.client.model.PipelineRunNode
import org.openapitools.client.model.PipelineStepImpl
import org.openapitools.client.model.QueueItemImpl
import org.openapitools.client.model.User
import org.openapitools.client.{ApiInvoker, ApiException}

import collection.mutable
import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart
import com.wordnik.swagger.client._
import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._
import javax.ws.rs.core.Response.Status.Family

import java.net.URI
import java.io.File
import java.util.Date
import java.util.TimeZone
import javax.ws.rs.core.{MediaType, Response}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.collection.mutable.HashMap
import scala.util.{Failure, Success, Try}

import org.json4s._

class BlueOceanApi(
  val defBasePath: String = "http://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new BlueOceanApiAsyncHelper(client, config)

  /**
   * 
   * Delete queue item from an organization pipeline queue
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param queue Name of the queue item 
   * @return void
   */
  def deletePipelineQueueItem(organization: String, pipeline: String, queue: String) = {
    val await = Try(Await.result(deletePipelineQueueItemAsync(organization, pipeline, queue), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Delete queue item from an organization pipeline queue
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param queue Name of the queue item 
   * @return Future(void)
   */
  def deletePipelineQueueItemAsync(organization: String, pipeline: String, queue: String) = {
      helper.deletePipelineQueueItem(organization, pipeline, queue)
  }

  /**
   * 
   * Retrieve authenticated user details for an organization
   *
   * @param organization Name of the organization 
   * @return User
   */
  def getAuthenticatedUser(organization: String): Option[User] = {
    val await = Try(Await.result(getAuthenticatedUserAsync(organization), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve authenticated user details for an organization
   *
   * @param organization Name of the organization 
   * @return Future(User)
   */
  def getAuthenticatedUserAsync(organization: String): Future[User] = {
      helper.getAuthenticatedUser(organization)
  }

  /**
   * 
   * Get a list of class names supported by a given class
   *
   * @param `class` Name of the class 
   * @return String
   */
  def getClasses(`class`: String): Option[String] = {
    val await = Try(Await.result(getClassesAsync(`class`), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Get a list of class names supported by a given class
   *
   * @param `class` Name of the class 
   * @return Future(String)
   */
  def getClassesAsync(`class`: String): Future[String] = {
      helper.getClasses(`class`)
  }

  /**
   * 
   * Retrieve JSON Web Key
   *
   * @param key Key ID received as part of JWT header field kid 
   * @return String
   */
  def getJsonWebKey(key: Integer): Option[String] = {
    val await = Try(Await.result(getJsonWebKeyAsync(key), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve JSON Web Key
   *
   * @param key Key ID received as part of JWT header field kid 
   * @return Future(String)
   */
  def getJsonWebKeyAsync(key: Integer): Future[String] = {
      helper.getJsonWebKey(key)
  }

  /**
   * 
   * Retrieve JSON Web Token
   *
   * @param expiryTimeInMins Token expiry time in minutes, default: 30 minutes (optional)
   * @param maxExpiryTimeInMins Maximum token expiry time in minutes, default: 480 minutes (optional)
   * @return String
   */
  def getJsonWebToken(expiryTimeInMins: Option[Integer] = None, maxExpiryTimeInMins: Option[Integer] = None): Option[String] = {
    val await = Try(Await.result(getJsonWebTokenAsync(expiryTimeInMins, maxExpiryTimeInMins), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve JSON Web Token
   *
   * @param expiryTimeInMins Token expiry time in minutes, default: 30 minutes (optional)
   * @param maxExpiryTimeInMins Maximum token expiry time in minutes, default: 480 minutes (optional)
   * @return Future(String)
   */
  def getJsonWebTokenAsync(expiryTimeInMins: Option[Integer] = None, maxExpiryTimeInMins: Option[Integer] = None): Future[String] = {
      helper.getJsonWebToken(expiryTimeInMins, maxExpiryTimeInMins)
  }

  /**
   * 
   * Retrieve organization details
   *
   * @param organization Name of the organization 
   * @return Organisation
   */
  def getOrganisation(organization: String): Option[Organisation] = {
    val await = Try(Await.result(getOrganisationAsync(organization), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve organization details
   *
   * @param organization Name of the organization 
   * @return Future(Organisation)
   */
  def getOrganisationAsync(organization: String): Future[Organisation] = {
      helper.getOrganisation(organization)
  }

  /**
   * 
   * Retrieve all organizations details
   *
   * @return List[Organisation]
   */
  def getOrganisations(): Option[List[Organisation]] = {
    val await = Try(Await.result(getOrganisationsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve all organizations details
   *
   * @return Future(List[Organisation])
   */
  def getOrganisationsAsync(): Future[List[Organisation]] = {
      helper.getOrganisations()
  }

  /**
   * 
   * Retrieve pipeline details for an organization
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return Pipeline
   */
  def getPipeline(organization: String, pipeline: String): Option[Pipeline] = {
    val await = Try(Await.result(getPipelineAsync(organization, pipeline), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve pipeline details for an organization
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return Future(Pipeline)
   */
  def getPipelineAsync(organization: String, pipeline: String): Future[Pipeline] = {
      helper.getPipeline(organization, pipeline)
  }

  /**
   * 
   * Retrieve all activities details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return List[PipelineActivity]
   */
  def getPipelineActivities(organization: String, pipeline: String): Option[List[PipelineActivity]] = {
    val await = Try(Await.result(getPipelineActivitiesAsync(organization, pipeline), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve all activities details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return Future(List[PipelineActivity])
   */
  def getPipelineActivitiesAsync(organization: String, pipeline: String): Future[List[PipelineActivity]] = {
      helper.getPipelineActivities(organization, pipeline)
  }

  /**
   * 
   * Retrieve branch details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param branch Name of the branch 
   * @return BranchImpl
   */
  def getPipelineBranch(organization: String, pipeline: String, branch: String): Option[BranchImpl] = {
    val await = Try(Await.result(getPipelineBranchAsync(organization, pipeline, branch), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve branch details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param branch Name of the branch 
   * @return Future(BranchImpl)
   */
  def getPipelineBranchAsync(organization: String, pipeline: String, branch: String): Future[BranchImpl] = {
      helper.getPipelineBranch(organization, pipeline, branch)
  }

  /**
   * 
   * Retrieve branch run details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param branch Name of the branch 
   * @param run Name of the run 
   * @return PipelineRun
   */
  def getPipelineBranchRun(organization: String, pipeline: String, branch: String, run: String): Option[PipelineRun] = {
    val await = Try(Await.result(getPipelineBranchRunAsync(organization, pipeline, branch, run), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve branch run details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param branch Name of the branch 
   * @param run Name of the run 
   * @return Future(PipelineRun)
   */
  def getPipelineBranchRunAsync(organization: String, pipeline: String, branch: String, run: String): Future[PipelineRun] = {
      helper.getPipelineBranchRun(organization, pipeline, branch, run)
  }

  /**
   * 
   * Retrieve all branches details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return MultibranchPipeline
   */
  def getPipelineBranches(organization: String, pipeline: String): Option[MultibranchPipeline] = {
    val await = Try(Await.result(getPipelineBranchesAsync(organization, pipeline), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve all branches details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return Future(MultibranchPipeline)
   */
  def getPipelineBranchesAsync(organization: String, pipeline: String): Future[MultibranchPipeline] = {
      helper.getPipelineBranches(organization, pipeline)
  }

  /**
   * 
   * Retrieve pipeline folder for an organization
   *
   * @param organization Name of the organization 
   * @param folder Name of the folder 
   * @return PipelineFolderImpl
   */
  def getPipelineFolder(organization: String, folder: String): Option[PipelineFolderImpl] = {
    val await = Try(Await.result(getPipelineFolderAsync(organization, folder), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve pipeline folder for an organization
   *
   * @param organization Name of the organization 
   * @param folder Name of the folder 
   * @return Future(PipelineFolderImpl)
   */
  def getPipelineFolderAsync(organization: String, folder: String): Future[PipelineFolderImpl] = {
      helper.getPipelineFolder(organization, folder)
  }

  /**
   * 
   * Retrieve pipeline details for an organization folder
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param folder Name of the folder 
   * @return PipelineImpl
   */
  def getPipelineFolderPipeline(organization: String, pipeline: String, folder: String): Option[PipelineImpl] = {
    val await = Try(Await.result(getPipelineFolderPipelineAsync(organization, pipeline, folder), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve pipeline details for an organization folder
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param folder Name of the folder 
   * @return Future(PipelineImpl)
   */
  def getPipelineFolderPipelineAsync(organization: String, pipeline: String, folder: String): Future[PipelineImpl] = {
      helper.getPipelineFolderPipeline(organization, pipeline, folder)
  }

  /**
   * 
   * Retrieve queue details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return List[QueueItemImpl]
   */
  def getPipelineQueue(organization: String, pipeline: String): Option[List[QueueItemImpl]] = {
    val await = Try(Await.result(getPipelineQueueAsync(organization, pipeline), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve queue details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return Future(List[QueueItemImpl])
   */
  def getPipelineQueueAsync(organization: String, pipeline: String): Future[List[QueueItemImpl]] = {
      helper.getPipelineQueue(organization, pipeline)
  }

  /**
   * 
   * Retrieve run details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @return PipelineRun
   */
  def getPipelineRun(organization: String, pipeline: String, run: String): Option[PipelineRun] = {
    val await = Try(Await.result(getPipelineRunAsync(organization, pipeline, run), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve run details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @return Future(PipelineRun)
   */
  def getPipelineRunAsync(organization: String, pipeline: String, run: String): Future[PipelineRun] = {
      helper.getPipelineRun(organization, pipeline, run)
  }

  /**
   * 
   * Get log for a pipeline run
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param start Start position of the log (optional)
   * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body (optional)
   * @return String
   */
  def getPipelineRunLog(organization: String, pipeline: String, run: String, start: Option[Integer] = None, download: Option[Boolean] = None): Option[String] = {
    val await = Try(Await.result(getPipelineRunLogAsync(organization, pipeline, run, start, download), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Get log for a pipeline run
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param start Start position of the log (optional)
   * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body (optional)
   * @return Future(String)
   */
  def getPipelineRunLogAsync(organization: String, pipeline: String, run: String, start: Option[Integer] = None, download: Option[Boolean] = None): Future[String] = {
      helper.getPipelineRunLog(organization, pipeline, run, start, download)
  }

  /**
   * 
   * Retrieve run node details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @return PipelineRunNode
   */
  def getPipelineRunNode(organization: String, pipeline: String, run: String, node: String): Option[PipelineRunNode] = {
    val await = Try(Await.result(getPipelineRunNodeAsync(organization, pipeline, run, node), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve run node details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @return Future(PipelineRunNode)
   */
  def getPipelineRunNodeAsync(organization: String, pipeline: String, run: String, node: String): Future[PipelineRunNode] = {
      helper.getPipelineRunNode(organization, pipeline, run, node)
  }

  /**
   * 
   * Retrieve run node details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @param step Name of the step 
   * @return PipelineStepImpl
   */
  def getPipelineRunNodeStep(organization: String, pipeline: String, run: String, node: String, step: String): Option[PipelineStepImpl] = {
    val await = Try(Await.result(getPipelineRunNodeStepAsync(organization, pipeline, run, node, step), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve run node details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @param step Name of the step 
   * @return Future(PipelineStepImpl)
   */
  def getPipelineRunNodeStepAsync(organization: String, pipeline: String, run: String, node: String, step: String): Future[PipelineStepImpl] = {
      helper.getPipelineRunNodeStep(organization, pipeline, run, node, step)
  }

  /**
   * 
   * Get log for a pipeline run node step
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @param step Name of the step 
   * @return String
   */
  def getPipelineRunNodeStepLog(organization: String, pipeline: String, run: String, node: String, step: String): Option[String] = {
    val await = Try(Await.result(getPipelineRunNodeStepLogAsync(organization, pipeline, run, node, step), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Get log for a pipeline run node step
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @param step Name of the step 
   * @return Future(String)
   */
  def getPipelineRunNodeStepLogAsync(organization: String, pipeline: String, run: String, node: String, step: String): Future[String] = {
      helper.getPipelineRunNodeStepLog(organization, pipeline, run, node, step)
  }

  /**
   * 
   * Retrieve run node steps details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @return List[PipelineStepImpl]
   */
  def getPipelineRunNodeSteps(organization: String, pipeline: String, run: String, node: String): Option[List[PipelineStepImpl]] = {
    val await = Try(Await.result(getPipelineRunNodeStepsAsync(organization, pipeline, run, node), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve run node steps details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param node Name of the node 
   * @return Future(List[PipelineStepImpl])
   */
  def getPipelineRunNodeStepsAsync(organization: String, pipeline: String, run: String, node: String): Future[List[PipelineStepImpl]] = {
      helper.getPipelineRunNodeSteps(organization, pipeline, run, node)
  }

  /**
   * 
   * Retrieve run nodes details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @return List[PipelineRunNode]
   */
  def getPipelineRunNodes(organization: String, pipeline: String, run: String): Option[List[PipelineRunNode]] = {
    val await = Try(Await.result(getPipelineRunNodesAsync(organization, pipeline, run), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve run nodes details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @return Future(List[PipelineRunNode])
   */
  def getPipelineRunNodesAsync(organization: String, pipeline: String, run: String): Future[List[PipelineRunNode]] = {
      helper.getPipelineRunNodes(organization, pipeline, run)
  }

  /**
   * 
   * Retrieve all runs details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return List[PipelineRun]
   */
  def getPipelineRuns(organization: String, pipeline: String): Option[List[PipelineRun]] = {
    val await = Try(Await.result(getPipelineRunsAsync(organization, pipeline), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve all runs details for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return Future(List[PipelineRun])
   */
  def getPipelineRunsAsync(organization: String, pipeline: String): Future[List[PipelineRun]] = {
      helper.getPipelineRuns(organization, pipeline)
  }

  /**
   * 
   * Retrieve all pipelines details for an organization
   *
   * @param organization Name of the organization 
   * @return List[Pipeline]
   */
  def getPipelines(organization: String): Option[List[Pipeline]] = {
    val await = Try(Await.result(getPipelinesAsync(organization), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve all pipelines details for an organization
   *
   * @param organization Name of the organization 
   * @return Future(List[Pipeline])
   */
  def getPipelinesAsync(organization: String): Future[List[Pipeline]] = {
      helper.getPipelines(organization)
  }

  /**
   * 
   * Retrieve SCM details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @return GithubScm
   */
  def getSCM(organization: String, scm: String): Option[GithubScm] = {
    val await = Try(Await.result(getSCMAsync(organization, scm), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve SCM details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @return Future(GithubScm)
   */
  def getSCMAsync(organization: String, scm: String): Future[GithubScm] = {
      helper.getSCM(organization, scm)
  }

  /**
   * 
   * Retrieve SCM organization repositories details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @param scmOrganisation Name of the SCM organization 
   * @param credentialId Credential ID (optional)
   * @param pageSize Number of items in a page (optional)
   * @param pageNumber Page number (optional)
   * @return List[GithubOrganization]
   */
  def getSCMOrganisationRepositories(organization: String, scm: String, scmOrganisation: String, credentialId: Option[String] = None, pageSize: Option[Integer] = None, pageNumber: Option[Integer] = None): Option[List[GithubOrganization]] = {
    val await = Try(Await.result(getSCMOrganisationRepositoriesAsync(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve SCM organization repositories details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @param scmOrganisation Name of the SCM organization 
   * @param credentialId Credential ID (optional)
   * @param pageSize Number of items in a page (optional)
   * @param pageNumber Page number (optional)
   * @return Future(List[GithubOrganization])
   */
  def getSCMOrganisationRepositoriesAsync(organization: String, scm: String, scmOrganisation: String, credentialId: Option[String] = None, pageSize: Option[Integer] = None, pageNumber: Option[Integer] = None): Future[List[GithubOrganization]] = {
      helper.getSCMOrganisationRepositories(organization, scm, scmOrganisation, credentialId, pageSize, pageNumber)
  }

  /**
   * 
   * Retrieve SCM organization repository details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @param scmOrganisation Name of the SCM organization 
   * @param repository Name of the SCM repository 
   * @param credentialId Credential ID (optional)
   * @return List[GithubOrganization]
   */
  def getSCMOrganisationRepository(organization: String, scm: String, scmOrganisation: String, repository: String, credentialId: Option[String] = None): Option[List[GithubOrganization]] = {
    val await = Try(Await.result(getSCMOrganisationRepositoryAsync(organization, scm, scmOrganisation, repository, credentialId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve SCM organization repository details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @param scmOrganisation Name of the SCM organization 
   * @param repository Name of the SCM repository 
   * @param credentialId Credential ID (optional)
   * @return Future(List[GithubOrganization])
   */
  def getSCMOrganisationRepositoryAsync(organization: String, scm: String, scmOrganisation: String, repository: String, credentialId: Option[String] = None): Future[List[GithubOrganization]] = {
      helper.getSCMOrganisationRepository(organization, scm, scmOrganisation, repository, credentialId)
  }

  /**
   * 
   * Retrieve SCM organizations details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @param credentialId Credential ID (optional)
   * @return List[GithubOrganization]
   */
  def getSCMOrganisations(organization: String, scm: String, credentialId: Option[String] = None): Option[List[GithubOrganization]] = {
    val await = Try(Await.result(getSCMOrganisationsAsync(organization, scm, credentialId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve SCM organizations details for an organization
   *
   * @param organization Name of the organization 
   * @param scm Name of SCM 
   * @param credentialId Credential ID (optional)
   * @return Future(List[GithubOrganization])
   */
  def getSCMOrganisationsAsync(organization: String, scm: String, credentialId: Option[String] = None): Future[List[GithubOrganization]] = {
      helper.getSCMOrganisations(organization, scm, credentialId)
  }

  /**
   * 
   * Retrieve user details for an organization
   *
   * @param organization Name of the organization 
   * @param user Name of the user 
   * @return User
   */
  def getUser(organization: String, user: String): Option[User] = {
    val await = Try(Await.result(getUserAsync(organization, user), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve user details for an organization
   *
   * @param organization Name of the organization 
   * @param user Name of the user 
   * @return Future(User)
   */
  def getUserAsync(organization: String, user: String): Future[User] = {
      helper.getUser(organization, user)
  }

  /**
   * 
   * Retrieve user favorites details for an organization
   *
   * @param user Name of the user 
   * @return List[FavoriteImpl]
   */
  def getUserFavorites(user: String): Option[List[FavoriteImpl]] = {
    val await = Try(Await.result(getUserFavoritesAsync(user), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve user favorites details for an organization
   *
   * @param user Name of the user 
   * @return Future(List[FavoriteImpl])
   */
  def getUserFavoritesAsync(user: String): Future[List[FavoriteImpl]] = {
      helper.getUserFavorites(user)
  }

  /**
   * 
   * Retrieve users details for an organization
   *
   * @param organization Name of the organization 
   * @return User
   */
  def getUsers(organization: String): Option[User] = {
    val await = Try(Await.result(getUsersAsync(organization), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Retrieve users details for an organization
   *
   * @param organization Name of the organization 
   * @return Future(User)
   */
  def getUsersAsync(organization: String): Future[User] = {
      helper.getUsers(organization)
  }

  /**
   * 
   * Replay an organization pipeline run
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @return QueueItemImpl
   */
  def postPipelineRun(organization: String, pipeline: String, run: String): Option[QueueItemImpl] = {
    val await = Try(Await.result(postPipelineRunAsync(organization, pipeline, run), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Replay an organization pipeline run
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @return Future(QueueItemImpl)
   */
  def postPipelineRunAsync(organization: String, pipeline: String, run: String): Future[QueueItemImpl] = {
      helper.postPipelineRun(organization, pipeline, run)
  }

  /**
   * 
   * Start a build for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return QueueItemImpl
   */
  def postPipelineRuns(organization: String, pipeline: String): Option[QueueItemImpl] = {
    val await = Try(Await.result(postPipelineRunsAsync(organization, pipeline), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Start a build for an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @return Future(QueueItemImpl)
   */
  def postPipelineRunsAsync(organization: String, pipeline: String): Future[QueueItemImpl] = {
      helper.postPipelineRuns(organization, pipeline)
  }

  /**
   * 
   * Favorite/unfavorite a pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite 
   * @return FavoriteImpl
   */
  def putPipelineFavorite(organization: String, pipeline: String, body: Boolean): Option[FavoriteImpl] = {
    val await = Try(Await.result(putPipelineFavoriteAsync(organization, pipeline, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Favorite/unfavorite a pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite 
   * @return Future(FavoriteImpl)
   */
  def putPipelineFavoriteAsync(organization: String, pipeline: String, body: Boolean): Future[FavoriteImpl] = {
      helper.putPipelineFavorite(organization, pipeline, body)
  }

  /**
   * 
   * Stop a build of an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param blocking Set to true to make blocking stop, default: false (optional)
   * @param timeOutInSecs Timeout in seconds, default: 10 seconds (optional)
   * @return PipelineRun
   */
  def putPipelineRun(organization: String, pipeline: String, run: String, blocking: Option[String] = None, timeOutInSecs: Option[Integer] = None): Option[PipelineRun] = {
    val await = Try(Await.result(putPipelineRunAsync(organization, pipeline, run, blocking, timeOutInSecs), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Stop a build of an organization pipeline
   *
   * @param organization Name of the organization 
   * @param pipeline Name of the pipeline 
   * @param run Name of the run 
   * @param blocking Set to true to make blocking stop, default: false (optional)
   * @param timeOutInSecs Timeout in seconds, default: 10 seconds (optional)
   * @return Future(PipelineRun)
   */
  def putPipelineRunAsync(organization: String, pipeline: String, run: String, blocking: Option[String] = None, timeOutInSecs: Option[Integer] = None): Future[PipelineRun] = {
      helper.putPipelineRun(organization, pipeline, run, blocking, timeOutInSecs)
  }

  /**
   * 
   * Search for any resource details
   *
   * @param q Query string 
   * @return String
   */
  def search(q: String): Option[String] = {
    val await = Try(Await.result(searchAsync(q), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Search for any resource details
   *
   * @param q Query string 
   * @return Future(String)
   */
  def searchAsync(q: String): Future[String] = {
      helper.search(q)
  }

  /**
   * 
   * Get classes details
   *
   * @param q Query string containing an array of class names 
   * @return String
   */
  def searchClasses(q: String): Option[String] = {
    val await = Try(Await.result(searchClassesAsync(q), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   *  asynchronously
   * Get classes details
   *
   * @param q Query string containing an array of class names 
   * @return Future(String)
   */
  def searchClassesAsync(q: String): Future[String] = {
      helper.searchClasses(q)
  }

}

class BlueOceanApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def deletePipelineQueueItem(organization: String,
    pipeline: String,
    queue: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "queue" + "\\}", queue.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->deletePipelineQueueItem")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->deletePipelineQueueItem")

    if (queue == null) throw new Exception("Missing required parameter 'queue' when calling BlueOceanApi->deletePipelineQueueItem")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getAuthenticatedUser(organization: String)(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/user/")
      replaceAll("\\{" + "organization" + "\\}", organization.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getAuthenticatedUser")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getClasses(`class`: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/classes/{class}")
      replaceAll("\\{" + "class" + "\\}", `class`.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`class` == null) throw new Exception("Missing required parameter '`class`' when calling BlueOceanApi->getClasses")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getJsonWebKey(key: Integer)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/jwt-auth/jwks/{key}")
      replaceAll("\\{" + "key" + "\\}", key.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getJsonWebToken(expiryTimeInMins: Option[Integer] = None,
    maxExpiryTimeInMins: Option[Integer] = None
    )(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/jwt-auth/token"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    expiryTimeInMins match {
      case Some(param) => queryParams += "expiryTimeInMins" -> param.toString
      case _ => queryParams
    }
    maxExpiryTimeInMins match {
      case Some(param) => queryParams += "maxExpiryTimeInMins" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getOrganisation(organization: String)(implicit reader: ClientResponseReader[Organisation]): Future[Organisation] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getOrganisation")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getOrganisations()(implicit reader: ClientResponseReader[List[Organisation]]): Future[List[Organisation]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipeline(organization: String,
    pipeline: String)(implicit reader: ClientResponseReader[Pipeline]): Future[Pipeline] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipeline")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipeline")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineActivities(organization: String,
    pipeline: String)(implicit reader: ClientResponseReader[List[PipelineActivity]]): Future[List[PipelineActivity]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineActivities")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineActivities")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineBranch(organization: String,
    pipeline: String,
    branch: String)(implicit reader: ClientResponseReader[BranchImpl]): Future[BranchImpl] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "branch" + "\\}", branch.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineBranch")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineBranch")

    if (branch == null) throw new Exception("Missing required parameter 'branch' when calling BlueOceanApi->getPipelineBranch")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineBranchRun(organization: String,
    pipeline: String,
    branch: String,
    run: String)(implicit reader: ClientResponseReader[PipelineRun]): Future[PipelineRun] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "branch" + "\\}", branch.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineBranchRun")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineBranchRun")

    if (branch == null) throw new Exception("Missing required parameter 'branch' when calling BlueOceanApi->getPipelineBranchRun")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineBranchRun")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineBranches(organization: String,
    pipeline: String)(implicit reader: ClientResponseReader[MultibranchPipeline]): Future[MultibranchPipeline] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineBranches")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineBranches")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineFolder(organization: String,
    folder: String)(implicit reader: ClientResponseReader[PipelineFolderImpl]): Future[PipelineFolderImpl] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{folder}/")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "folder" + "\\}", folder.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineFolder")

    if (folder == null) throw new Exception("Missing required parameter 'folder' when calling BlueOceanApi->getPipelineFolder")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineFolderPipeline(organization: String,
    pipeline: String,
    folder: String)(implicit reader: ClientResponseReader[PipelineImpl]): Future[PipelineImpl] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "folder" + "\\}", folder.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineFolderPipeline")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineFolderPipeline")

    if (folder == null) throw new Exception("Missing required parameter 'folder' when calling BlueOceanApi->getPipelineFolderPipeline")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineQueue(organization: String,
    pipeline: String)(implicit reader: ClientResponseReader[List[QueueItemImpl]]): Future[List[QueueItemImpl]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineQueue")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineQueue")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRun(organization: String,
    pipeline: String,
    run: String)(implicit reader: ClientResponseReader[PipelineRun]): Future[PipelineRun] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRun")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRun")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineRun")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRunLog(organization: String,
    pipeline: String,
    run: String,
    start: Option[Integer] = None,
    download: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRunLog")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRunLog")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineRunLog")

    start match {
      case Some(param) => queryParams += "start" -> param.toString
      case _ => queryParams
    }
    download match {
      case Some(param) => queryParams += "download" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRunNode(organization: String,
    pipeline: String,
    run: String,
    node: String)(implicit reader: ClientResponseReader[PipelineRunNode]): Future[PipelineRunNode] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString)
      replaceAll("\\{" + "node" + "\\}", node.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRunNode")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRunNode")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineRunNode")

    if (node == null) throw new Exception("Missing required parameter 'node' when calling BlueOceanApi->getPipelineRunNode")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRunNodeStep(organization: String,
    pipeline: String,
    run: String,
    node: String,
    step: String)(implicit reader: ClientResponseReader[PipelineStepImpl]): Future[PipelineStepImpl] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString)
      replaceAll("\\{" + "node" + "\\}", node.toString)
      replaceAll("\\{" + "step" + "\\}", step.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRunNodeStep")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRunNodeStep")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineRunNodeStep")

    if (node == null) throw new Exception("Missing required parameter 'node' when calling BlueOceanApi->getPipelineRunNodeStep")

    if (step == null) throw new Exception("Missing required parameter 'step' when calling BlueOceanApi->getPipelineRunNodeStep")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRunNodeStepLog(organization: String,
    pipeline: String,
    run: String,
    node: String,
    step: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString)
      replaceAll("\\{" + "node" + "\\}", node.toString)
      replaceAll("\\{" + "step" + "\\}", step.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRunNodeStepLog")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRunNodeStepLog")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineRunNodeStepLog")

    if (node == null) throw new Exception("Missing required parameter 'node' when calling BlueOceanApi->getPipelineRunNodeStepLog")

    if (step == null) throw new Exception("Missing required parameter 'step' when calling BlueOceanApi->getPipelineRunNodeStepLog")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRunNodeSteps(organization: String,
    pipeline: String,
    run: String,
    node: String)(implicit reader: ClientResponseReader[List[PipelineStepImpl]]): Future[List[PipelineStepImpl]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString)
      replaceAll("\\{" + "node" + "\\}", node.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRunNodeSteps")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRunNodeSteps")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineRunNodeSteps")

    if (node == null) throw new Exception("Missing required parameter 'node' when calling BlueOceanApi->getPipelineRunNodeSteps")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRunNodes(organization: String,
    pipeline: String,
    run: String)(implicit reader: ClientResponseReader[List[PipelineRunNode]]): Future[List[PipelineRunNode]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRunNodes")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRunNodes")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->getPipelineRunNodes")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelineRuns(organization: String,
    pipeline: String)(implicit reader: ClientResponseReader[List[PipelineRun]]): Future[List[PipelineRun]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelineRuns")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->getPipelineRuns")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getPipelines(organization: String)(implicit reader: ClientResponseReader[List[Pipeline]]): Future[List[Pipeline]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/")
      replaceAll("\\{" + "organization" + "\\}", organization.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getPipelines")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getSCM(organization: String,
    scm: String)(implicit reader: ClientResponseReader[GithubScm]): Future[GithubScm] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/scm/{scm}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "scm" + "\\}", scm.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getSCM")

    if (scm == null) throw new Exception("Missing required parameter 'scm' when calling BlueOceanApi->getSCM")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getSCMOrganisationRepositories(organization: String,
    scm: String,
    scmOrganisation: String,
    credentialId: Option[String] = None,
    pageSize: Option[Integer] = None,
    pageNumber: Option[Integer] = None
    )(implicit reader: ClientResponseReader[List[GithubOrganization]]): Future[List[GithubOrganization]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "scm" + "\\}", scm.toString)
      replaceAll("\\{" + "scmOrganisation" + "\\}", scmOrganisation.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getSCMOrganisationRepositories")

    if (scm == null) throw new Exception("Missing required parameter 'scm' when calling BlueOceanApi->getSCMOrganisationRepositories")

    if (scmOrganisation == null) throw new Exception("Missing required parameter 'scmOrganisation' when calling BlueOceanApi->getSCMOrganisationRepositories")

    credentialId match {
      case Some(param) => queryParams += "credentialId" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "pageSize" -> param.toString
      case _ => queryParams
    }
    pageNumber match {
      case Some(param) => queryParams += "pageNumber" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getSCMOrganisationRepository(organization: String,
    scm: String,
    scmOrganisation: String,
    repository: String,
    credentialId: Option[String] = None
    )(implicit reader: ClientResponseReader[List[GithubOrganization]]): Future[List[GithubOrganization]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "scm" + "\\}", scm.toString)
      replaceAll("\\{" + "scmOrganisation" + "\\}", scmOrganisation.toString)
      replaceAll("\\{" + "repository" + "\\}", repository.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getSCMOrganisationRepository")

    if (scm == null) throw new Exception("Missing required parameter 'scm' when calling BlueOceanApi->getSCMOrganisationRepository")

    if (scmOrganisation == null) throw new Exception("Missing required parameter 'scmOrganisation' when calling BlueOceanApi->getSCMOrganisationRepository")

    if (repository == null) throw new Exception("Missing required parameter 'repository' when calling BlueOceanApi->getSCMOrganisationRepository")

    credentialId match {
      case Some(param) => queryParams += "credentialId" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getSCMOrganisations(organization: String,
    scm: String,
    credentialId: Option[String] = None
    )(implicit reader: ClientResponseReader[List[GithubOrganization]]): Future[List[GithubOrganization]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/scm/{scm}/organizations")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "scm" + "\\}", scm.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getSCMOrganisations")

    if (scm == null) throw new Exception("Missing required parameter 'scm' when calling BlueOceanApi->getSCMOrganisations")

    credentialId match {
      case Some(param) => queryParams += "credentialId" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getUser(organization: String,
    user: String)(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/users/{user}")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "user" + "\\}", user.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getUser")

    if (user == null) throw new Exception("Missing required parameter 'user' when calling BlueOceanApi->getUser")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getUserFavorites(user: String)(implicit reader: ClientResponseReader[List[FavoriteImpl]]): Future[List[FavoriteImpl]] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/users/{user}/favorites")
      replaceAll("\\{" + "user" + "\\}", user.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (user == null) throw new Exception("Missing required parameter 'user' when calling BlueOceanApi->getUserFavorites")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def getUsers(organization: String)(implicit reader: ClientResponseReader[User]): Future[User] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/users/")
      replaceAll("\\{" + "organization" + "\\}", organization.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->getUsers")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def postPipelineRun(organization: String,
    pipeline: String,
    run: String)(implicit reader: ClientResponseReader[QueueItemImpl]): Future[QueueItemImpl] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->postPipelineRun")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->postPipelineRun")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->postPipelineRun")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def postPipelineRuns(organization: String,
    pipeline: String)(implicit reader: ClientResponseReader[QueueItemImpl]): Future[QueueItemImpl] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->postPipelineRuns")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->postPipelineRuns")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def putPipelineFavorite(organization: String,
    pipeline: String,
    body: Boolean)(implicit reader: ClientResponseReader[FavoriteImpl], writer: RequestWriter[Boolean]): Future[FavoriteImpl] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->putPipelineFavorite")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->putPipelineFavorite")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def putPipelineRun(organization: String,
    pipeline: String,
    run: String,
    blocking: Option[String] = None,
    timeOutInSecs: Option[Integer] = None
    )(implicit reader: ClientResponseReader[PipelineRun]): Future[PipelineRun] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop")
      replaceAll("\\{" + "organization" + "\\}", organization.toString)
      replaceAll("\\{" + "pipeline" + "\\}", pipeline.toString)
      replaceAll("\\{" + "run" + "\\}", run.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (organization == null) throw new Exception("Missing required parameter 'organization' when calling BlueOceanApi->putPipelineRun")

    if (pipeline == null) throw new Exception("Missing required parameter 'pipeline' when calling BlueOceanApi->putPipelineRun")

    if (run == null) throw new Exception("Missing required parameter 'run' when calling BlueOceanApi->putPipelineRun")

    blocking match {
      case Some(param) => queryParams += "blocking" -> param.toString
      case _ => queryParams
    }
    timeOutInSecs match {
      case Some(param) => queryParams += "timeOutInSecs" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def search(q: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/search/"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (q == null) throw new Exception("Missing required parameter 'q' when calling BlueOceanApi->search")

    queryParams += "q" -> q.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }

  def searchClasses(q: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/blue/rest/classes/"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (q == null) throw new Exception("Missing required parameter 'q' when calling BlueOceanApi->searchClasses")

    queryParams += "q" -> q.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      val status = Response.Status.fromStatusCode(resp.statusCode)
      status.getFamily match {
        case Family.SUCCESSFUL | Family.REDIRECTION | Family.INFORMATIONAL => process(reader.read(resp))
        case _ => throw new ApiException(resp.statusCode, resp.statusText)
      }
    }
  }


}
