/* tslint:disable */
/* eslint-disable */
/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * The version of the OpenAPI document: 1.1.1
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    ComputerSet,
    ComputerSetFromJSON,
    ComputerSetToJSON,
    FreeStyleBuild,
    FreeStyleBuildFromJSON,
    FreeStyleBuildToJSON,
    FreeStyleProject,
    FreeStyleProjectFromJSON,
    FreeStyleProjectToJSON,
    Hudson,
    HudsonFromJSON,
    HudsonToJSON,
    ListView,
    ListViewFromJSON,
    ListViewToJSON,
    Queue,
    QueueFromJSON,
    QueueToJSON,
} from '../models';

export interface GetComputerRequest {
    depth: number;
}

export interface GetJobRequest {
    name: string;
}

export interface GetJobConfigRequest {
    name: string;
}

export interface GetJobLastBuildRequest {
    name: string;
}

export interface GetJobProgressiveTextRequest {
    name: string;
    number: string;
    start: string;
}

export interface GetQueueItemRequest {
    number: string;
}

export interface GetViewRequest {
    name: string;
}

export interface GetViewConfigRequest {
    name: string;
}

export interface PostCreateItemRequest {
    name: string;
    from?: string;
    mode?: string;
    jenkinsCrumb?: string;
    contentType?: string;
    body?: string;
}

export interface PostCreateViewRequest {
    name: string;
    jenkinsCrumb?: string;
    contentType?: string;
    body?: string;
}

export interface PostJobBuildRequest {
    name: string;
    json: string;
    token?: string;
    jenkinsCrumb?: string;
}

export interface PostJobConfigRequest {
    name: string;
    body: string;
    jenkinsCrumb?: string;
}

export interface PostJobDeleteRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostJobDisableRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostJobEnableRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostJobLastBuildStopRequest {
    name: string;
    jenkinsCrumb?: string;
}

export interface PostViewConfigRequest {
    name: string;
    body: string;
    jenkinsCrumb?: string;
}

/**
 * 
 */
export class RemoteAccessApi extends runtime.BaseAPI {

    /**
     * Retrieve computer details
     */
    async getComputerRaw(requestParameters: GetComputerRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ComputerSet>> {
        if (requestParameters.depth === null || requestParameters.depth === undefined) {
            throw new runtime.RequiredError('depth','Required parameter requestParameters.depth was null or undefined when calling getComputer.');
        }

        const queryParameters: any = {};

        if (requestParameters.depth !== undefined) {
            queryParameters['depth'] = requestParameters.depth;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/computer/api/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ComputerSetFromJSON(jsonValue));
    }

    /**
     * Retrieve computer details
     */
    async getComputer(requestParameters: GetComputerRequest, initOverrides?: RequestInit): Promise<ComputerSet> {
        const response = await this.getComputerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Jenkins details
     */
    async getJenkinsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Hudson>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HudsonFromJSON(jsonValue));
    }

    /**
     * Retrieve Jenkins details
     */
    async getJenkins(initOverrides?: RequestInit): Promise<Hudson> {
        const response = await this.getJenkinsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job details
     */
    async getJobRaw(requestParameters: GetJobRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FreeStyleProject>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getJob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/api/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FreeStyleProjectFromJSON(jsonValue));
    }

    /**
     * Retrieve job details
     */
    async getJob(requestParameters: GetJobRequest, initOverrides?: RequestInit): Promise<FreeStyleProject> {
        const response = await this.getJobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job configuration
     */
    async getJobConfigRaw(requestParameters: GetJobConfigRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getJobConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Retrieve job configuration
     */
    async getJobConfig(requestParameters: GetJobConfigRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.getJobConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job\'s last build details
     */
    async getJobLastBuildRaw(requestParameters: GetJobLastBuildRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<FreeStyleBuild>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getJobLastBuild.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/lastBuild/api/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FreeStyleBuildFromJSON(jsonValue));
    }

    /**
     * Retrieve job\'s last build details
     */
    async getJobLastBuild(requestParameters: GetJobLastBuildRequest, initOverrides?: RequestInit): Promise<FreeStyleBuild> {
        const response = await this.getJobLastBuildRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve job\'s build progressive text output
     */
    async getJobProgressiveTextRaw(requestParameters: GetJobProgressiveTextRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getJobProgressiveText.');
        }

        if (requestParameters.number === null || requestParameters.number === undefined) {
            throw new runtime.RequiredError('number','Required parameter requestParameters.number was null or undefined when calling getJobProgressiveText.');
        }

        if (requestParameters.start === null || requestParameters.start === undefined) {
            throw new runtime.RequiredError('start','Required parameter requestParameters.start was null or undefined when calling getJobProgressiveText.');
        }

        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/{number}/logText/progressiveText`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"number"}}`, encodeURIComponent(String(requestParameters.number))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve job\'s build progressive text output
     */
    async getJobProgressiveText(requestParameters: GetJobProgressiveTextRequest, initOverrides?: RequestInit): Promise<void> {
        await this.getJobProgressiveTextRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieve queue details
     */
    async getQueueRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<Queue>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/queue/api/json`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueueFromJSON(jsonValue));
    }

    /**
     * Retrieve queue details
     */
    async getQueue(initOverrides?: RequestInit): Promise<Queue> {
        const response = await this.getQueueRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve queued item details
     */
    async getQueueItemRaw(requestParameters: GetQueueItemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<Queue>> {
        if (requestParameters.number === null || requestParameters.number === undefined) {
            throw new runtime.RequiredError('number','Required parameter requestParameters.number was null or undefined when calling getQueueItem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/queue/item/{number}/api/json`.replace(`{${"number"}}`, encodeURIComponent(String(requestParameters.number))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueueFromJSON(jsonValue));
    }

    /**
     * Retrieve queued item details
     */
    async getQueueItem(requestParameters: GetQueueItemRequest, initOverrides?: RequestInit): Promise<Queue> {
        const response = await this.getQueueItemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve view details
     */
    async getViewRaw(requestParameters: GetViewRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<ListView>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getView.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/view/{name}/api/json`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListViewFromJSON(jsonValue));
    }

    /**
     * Retrieve view details
     */
    async getView(requestParameters: GetViewRequest, initOverrides?: RequestInit): Promise<ListView> {
        const response = await this.getViewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve view configuration
     */
    async getViewConfigRaw(requestParameters: GetViewConfigRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getViewConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/view/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Retrieve view configuration
     */
    async getViewConfig(requestParameters: GetViewConfigRequest, initOverrides?: RequestInit): Promise<string> {
        const response = await this.getViewConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Jenkins headers
     */
    async headJenkinsRaw(initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/json`,
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieve Jenkins headers
     */
    async headJenkins(initOverrides?: RequestInit): Promise<void> {
        await this.headJenkinsRaw(initOverrides);
    }

    /**
     * Create a new job using job configuration, or copied from an existing job
     */
    async postCreateItemRaw(requestParameters: PostCreateItemRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postCreateItem.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.mode !== undefined) {
            queryParameters['mode'] = requestParameters.mode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/createItem`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new job using job configuration, or copied from an existing job
     */
    async postCreateItem(requestParameters: PostCreateItemRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postCreateItemRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new view using view configuration
     */
    async postCreateViewRaw(requestParameters: PostCreateViewRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postCreateView.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
            headerParameters['Content-Type'] = String(requestParameters.contentType);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/createView`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new view using view configuration
     */
    async postCreateView(requestParameters: PostCreateViewRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postCreateViewRaw(requestParameters, initOverrides);
    }

    /**
     * Build a job
     */
    async postJobBuildRaw(requestParameters: PostJobBuildRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postJobBuild.');
        }

        if (requestParameters.json === null || requestParameters.json === undefined) {
            throw new runtime.RequiredError('json','Required parameter requestParameters.json was null or undefined when calling postJobBuild.');
        }

        const queryParameters: any = {};

        if (requestParameters.json !== undefined) {
            queryParameters['json'] = requestParameters.json;
        }

        if (requestParameters.token !== undefined) {
            queryParameters['token'] = requestParameters.token;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/build`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Build a job
     */
    async postJobBuild(requestParameters: PostJobBuildRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postJobBuildRaw(requestParameters, initOverrides);
    }

    /**
     * Update job configuration
     */
    async postJobConfigRaw(requestParameters: PostJobConfigRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postJobConfig.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postJobConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update job configuration
     */
    async postJobConfig(requestParameters: PostJobConfigRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postJobConfigRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a job
     */
    async postJobDeleteRaw(requestParameters: PostJobDeleteRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postJobDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/doDelete`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a job
     */
    async postJobDelete(requestParameters: PostJobDeleteRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postJobDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Disable a job
     */
    async postJobDisableRaw(requestParameters: PostJobDisableRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postJobDisable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/disable`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable a job
     */
    async postJobDisable(requestParameters: PostJobDisableRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postJobDisableRaw(requestParameters, initOverrides);
    }

    /**
     * Enable a job
     */
    async postJobEnableRaw(requestParameters: PostJobEnableRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postJobEnable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/enable`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable a job
     */
    async postJobEnable(requestParameters: PostJobEnableRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postJobEnableRaw(requestParameters, initOverrides);
    }

    /**
     * Stop a job
     */
    async postJobLastBuildStopRaw(requestParameters: PostJobLastBuildStopRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postJobLastBuildStop.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/job/{name}/lastBuild/stop`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop a job
     */
    async postJobLastBuildStop(requestParameters: PostJobLastBuildStopRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postJobLastBuildStopRaw(requestParameters, initOverrides);
    }

    /**
     * Update view configuration
     */
    async postViewConfigRaw(requestParameters: PostViewConfigRequest, initOverrides?: RequestInit): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling postViewConfig.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling postViewConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.jenkinsCrumb !== undefined && requestParameters.jenkinsCrumb !== null) {
            headerParameters['Jenkins-Crumb'] = String(requestParameters.jenkinsCrumb);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/view/{name}/config.xml`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update view configuration
     */
    async postViewConfig(requestParameters: PostViewConfigRequest, initOverrides?: RequestInit): Promise<void> {
        await this.postViewConfigRaw(requestParameters, initOverrides);
    }

}
