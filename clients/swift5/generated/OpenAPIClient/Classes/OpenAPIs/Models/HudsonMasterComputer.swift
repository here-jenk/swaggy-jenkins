//
// HudsonMasterComputer.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct HudsonMasterComputer: Codable, JSONEncodable, Hashable {

    public var _class: String?
    public var displayName: String?
    public var executors: [HudsonMasterComputerexecutors]?
    public var icon: String?
    public var iconClassName: String?
    public var idle: Bool?
    public var jnlpAgent: Bool?
    public var launchSupported: Bool?
    public var loadStatistics: Label1?
    public var manualLaunchAllowed: Bool?
    public var monitorData: HudsonMasterComputermonitorData?
    public var numExecutors: Int?
    public var offline: Bool?
    public var offlineCause: String?
    public var offlineCauseReason: String?
    public var temporarilyOffline: Bool?

    public init(_class: String? = nil, displayName: String? = nil, executors: [HudsonMasterComputerexecutors]? = nil, icon: String? = nil, iconClassName: String? = nil, idle: Bool? = nil, jnlpAgent: Bool? = nil, launchSupported: Bool? = nil, loadStatistics: Label1? = nil, manualLaunchAllowed: Bool? = nil, monitorData: HudsonMasterComputermonitorData? = nil, numExecutors: Int? = nil, offline: Bool? = nil, offlineCause: String? = nil, offlineCauseReason: String? = nil, temporarilyOffline: Bool? = nil) {
        self._class = _class
        self.displayName = displayName
        self.executors = executors
        self.icon = icon
        self.iconClassName = iconClassName
        self.idle = idle
        self.jnlpAgent = jnlpAgent
        self.launchSupported = launchSupported
        self.loadStatistics = loadStatistics
        self.manualLaunchAllowed = manualLaunchAllowed
        self.monitorData = monitorData
        self.numExecutors = numExecutors
        self.offline = offline
        self.offlineCause = offlineCause
        self.offlineCauseReason = offlineCauseReason
        self.temporarilyOffline = temporarilyOffline
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case _class
        case displayName
        case executors
        case icon
        case iconClassName
        case idle
        case jnlpAgent
        case launchSupported
        case loadStatistics
        case manualLaunchAllowed
        case monitorData
        case numExecutors
        case offline
        case offlineCause
        case offlineCauseReason
        case temporarilyOffline
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(_class, forKey: ._class)
        try container.encodeIfPresent(displayName, forKey: .displayName)
        try container.encodeIfPresent(executors, forKey: .executors)
        try container.encodeIfPresent(icon, forKey: .icon)
        try container.encodeIfPresent(iconClassName, forKey: .iconClassName)
        try container.encodeIfPresent(idle, forKey: .idle)
        try container.encodeIfPresent(jnlpAgent, forKey: .jnlpAgent)
        try container.encodeIfPresent(launchSupported, forKey: .launchSupported)
        try container.encodeIfPresent(loadStatistics, forKey: .loadStatistics)
        try container.encodeIfPresent(manualLaunchAllowed, forKey: .manualLaunchAllowed)
        try container.encodeIfPresent(monitorData, forKey: .monitorData)
        try container.encodeIfPresent(numExecutors, forKey: .numExecutors)
        try container.encodeIfPresent(offline, forKey: .offline)
        try container.encodeIfPresent(offlineCause, forKey: .offlineCause)
        try container.encodeIfPresent(offlineCauseReason, forKey: .offlineCauseReason)
        try container.encodeIfPresent(temporarilyOffline, forKey: .temporarilyOffline)
    }
}

